package de.fayard.versions.internal

import org.gradle.api.Project
import org.gradle.api.artifacts.ModuleIdentifier
import java.io.File

internal data class DependencyWithVersionCandidates(
    val moduleIdentifier: ModuleIdentifier,
    val currentVersion: String,
    val versionsCandidates: List<VersionCandidate>
)

internal fun Project.updateVersionsProperties(
    dependenciesWithLastVersion: List<DependencyWithVersionCandidates>
) {
    val file = file("versions.properties")
    if (file.exists().not()) file.createNewFile()

    val properties: Map<String, String> = getVersionProperties()
    val versionKeyReader = gradle.retrieveVersionKeyReader()

    val newFileContent = buildString {
        appendln(fileHeader)
        //TODO: Keep comments from user (ours begin with ##, while user's begin with a single #),
        // property related comments are placed above it. Also keep header and footer comments.
        val versionsWithUpdatesIfAvailable: List<VersionWithUpdateIfAvailable> = dependenciesWithLastVersion
            .mapNotNull { (moduleIdentifier, currentVersion, versionsCandidates) ->
                val propertyName = getVersionPropertyName(moduleIdentifier, versionKeyReader)
                if (currentVersion.isAVersionAlias()) return@mapNotNull null
                VersionWithUpdateIfAvailable(
                    key = propertyName,
                    currentVersion = currentVersion,
                    versionsCandidates = versionsCandidates
                )
            }
            .distinctBy { it.key }
        val versionAliases: List<VersionWithUpdateIfAvailable> = properties.mapNotNull { (k, v) ->
            v.takeIf { version -> version.isAVersionAlias() }?.let {
                VersionWithUpdateIfAvailable(
                    key = k,
                    currentVersion = v,
                    versionsCandidates = emptyList()
                )
            }
        }
        (versionsWithUpdatesIfAvailable + versionAliases)
            .sortedBy { it.key }
            .forEach { appendVersionWithUpdatesIfAvailable(it) }
    }
    file.writeText(newFileContent)
}

internal fun writeWithAddedVersions(
    versionsFile: File,
    propertyName: String,
    versionsCandidates: List<VersionCandidate>
) {
    val newFileContent = buildString {
        val existingContent = versionsFile.readText()
        if (existingContent.isBlank()) {
            appendln(fileHeader)
        } else {
            append(existingContent)
        }
        //TODO: Add new version in the right order regarding existing version properties
        appendVersionWithUpdatesIfAvailable(
            VersionWithUpdateIfAvailable(
                key = propertyName,
                currentVersion = versionsCandidates.first().version.value,
                versionsCandidates = versionsCandidates.drop(1)
            )
        )
    }
    versionsFile.writeText(newFileContent)
}

private fun StringBuilder.appendVersionWithUpdatesIfAvailable(it: VersionWithUpdateIfAvailable) {
    appendln()
    val paddedKey = it.key.padStart(available.length + 2)
    val currentVersionLine = "${paddedKey}=${it.currentVersion}"
    appendln(currentVersionLine)
    it.versionsCandidates.forEach { versionCandidate ->
        append("##"); append(available.padStart(it.key.length - 2))
        append('='); appendln(versionCandidate.version.value)
    }
}

private const val available = "# available"
private val fileHeader = """
    |## suppress inspection "SpellCheckingInspection" for whole file
    |## suppress inspection "UnusedProperty" for whole file
    |##
    |## Dependencies and Plugin versions with their available updates
    |## Generated by ${'$'} ./gradlew refreshVersions
    |## Please, don't put extra comments in that file yet, keeping them is not supported yet.
""".trimMargin()

private class VersionWithUpdateIfAvailable(
    val key: String,
    val currentVersion: String,
    val versionsCandidates: List<VersionCandidate>
)
